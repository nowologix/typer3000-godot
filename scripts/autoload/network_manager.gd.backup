## network_manager.gd
## Handles TCP networking via relay server
## Autoload singleton: NetworkManager
extends Node

# Relay server configuration
const RELAY_HOST: String = "167.99.128.216"
const RELAY_PORT: int = 7777

# Connection state
enum ConnectionState {
	DISCONNECTED,
	CONNECTING,
	CONNECTED,
	IN_LOBBY,
	IN_GAME
}

var state: ConnectionState = ConnectionState.DISCONNECTED
var socket: StreamPeerTCP = null
var lobby_code: String = ""
var player_id: int = 0
var player_name: String = "Player"
var is_host: bool = false

# Other players in lobby
var players: Dictionary = {}  # id -> {name, ready, score}

# Message buffer
var message_buffer: String = ""

# Reconnection
var reconnect_attempts: int = 0
const MAX_RECONNECT_ATTEMPTS: int = 3

func _ready() -> void:
	DebugHelper.log_info("NetworkManager initialized (relay: %s:%d)" % [RELAY_HOST, RELAY_PORT])

func _process(_delta: float) -> void:
	if socket == null:
		return

	# Check connection status
	socket.poll()
	var status = socket.get_status()

	match status:
		StreamPeerTCP.STATUS_NONE:
			if state != ConnectionState.DISCONNECTED:
				on_disconnected("Connection lost")
		StreamPeerTCP.STATUS_CONNECTING:
			pass
		StreamPeerTCP.STATUS_CONNECTED:
			if state == ConnectionState.CONNECTING:
				on_connected()
			receive_data()
		StreamPeerTCP.STATUS_ERROR:
			on_disconnected("Connection error")

func connect_to_relay() -> void:
	if socket != null:
		disconnect_from_relay()

	socket = StreamPeerTCP.new()
	state = ConnectionState.CONNECTING
	reconnect_attempts = 0

	var error = socket.connect_to_host(RELAY_HOST, RELAY_PORT)
	if error != OK:
		DebugHelper.log_error("NetworkManager: Failed to initiate connection: %s" % error)
		on_disconnected("Failed to connect")
	else:
		DebugHelper.log_info("NetworkManager: Connecting to relay...")

func disconnect_from_relay() -> void:
	if socket != null:
		socket.disconnect_from_host()
		socket = null

	state = ConnectionState.DISCONNECTED
	lobby_code = ""
	players.clear()

	DebugHelper.log_info("NetworkManager: Disconnected from relay")
	SignalBus.network_disconnected.emit("Manual disconnect")

func on_connected() -> void:
	state = ConnectionState.CONNECTED
	DebugHelper.log_info("NetworkManager: Connected to relay!")
	SignalBus.network_connected.emit()

	# Send hello message
	send_message({
		"type": "HELLO",
		"name": player_name,
		"version": "1.0"
	})

func on_disconnected(reason: String) -> void:
	state = ConnectionState.DISCONNECTED
	socket = null

	DebugHelper.log_warning("NetworkManager: Disconnected - %s" % reason)
	SignalBus.network_disconnected.emit(reason)

	# Attempt reconnect if we were in a game
	if reconnect_attempts < MAX_RECONNECT_ATTEMPTS and lobby_code != "":
		reconnect_attempts += 1
		DebugHelper.log_info("NetworkManager: Reconnection attempt %d/%d" % [reconnect_attempts, MAX_RECONNECT_ATTEMPTS])
		call_deferred("connect_to_relay")

func send_message(data: Dictionary) -> void:
	if socket == null or state == ConnectionState.DISCONNECTED:
		DebugHelper.log_warning("NetworkManager: Cannot send - not connected")
		return

	var json_string = JSON.stringify(data)
	var message = json_string + "\n"
	socket.put_data(message.to_utf8_buffer())

func receive_data() -> void:
	if socket == null:
		return

	var available = socket.get_available_bytes()
	if available <= 0:
		return

	var data = socket.get_data(available)
	if data[0] != OK:
		return

	var text = data[1].get_string_from_utf8()
	message_buffer += text

	# Process complete messages (newline delimited)
	while message_buffer.contains("\n"):
		var newline_pos = message_buffer.find("\n")
		var message = message_buffer.substr(0, newline_pos)
		message_buffer = message_buffer.substr(newline_pos + 1)

		if message.length() > 0:
			process_message(message)

func process_message(message: String) -> void:
	var json = JSON.new()
	var error = json.parse(message)
	if error != OK:
		DebugHelper.log_error("NetworkManager: Invalid JSON: %s" % message)
		return

	var data = json.get_data()
	if not data is Dictionary:
		return

	var msg_type = data.get("type", "")
	DebugHelper.log_debug("NetworkManager: Received %s" % msg_type)

	match msg_type:
		"WELCOME":
			player_id = data.get("id", 0)
			DebugHelper.log_info("NetworkManager: Assigned player ID %d" % player_id)

		"LOBBY_CREATED":
			lobby_code = data.get("code", "")
			is_host = true
			state = ConnectionState.IN_LOBBY
			DebugHelper.log_info("NetworkManager: Lobby created with code %s" % lobby_code)
			SignalBus.lobby_created.emit(lobby_code)

		"LOBBY_JOINED":
			lobby_code = data.get("code", "")
			is_host = false
			state = ConnectionState.IN_LOBBY
			DebugHelper.log_info("NetworkManager: Joined lobby %s" % lobby_code)
			SignalBus.lobby_joined.emit(lobby_code)

		"PLAYER_JOINED":
			var pid = data.get("id", 0)
			var pname = data.get("name", "Unknown")
			players[pid] = {"name": pname, "ready": false, "score": 0}
			DebugHelper.log_info("NetworkManager: Player joined - %s" % pname)
			SignalBus.player_joined.emit(pid, pname)

		"PLAYER_LEFT":
			var pid = data.get("id", 0)
			if players.has(pid):
				var pname = players[pid].name
				players.erase(pid)
				DebugHelper.log_info("NetworkManager: Player left - %s" % pname)
				SignalBus.player_left.emit(pid)

		"GAME_START":
			state = ConnectionState.IN_GAME
			var seed = data.get("seed", 0)
			DebugHelper.log_info("NetworkManager: Game starting with seed %d" % seed)
			SignalBus.network_game_start.emit(seed)

		"PLAYER_SCORE":
			var pid = data.get("id", 0)
			var score = data.get("score", 0)
			if players.has(pid):
				players[pid].score = score
			SignalBus.network_score_update.emit(pid, score)

		"PLAYER_WORD":
			var pid = data.get("id", 0)
			var word = data.get("word", "")
			SignalBus.network_word_completed.emit(pid, word)

		"GAME_OVER":
			var winner_id = data.get("winner", 0)
			var final_scores = data.get("scores", {})
			SignalBus.network_game_over.emit(winner_id, final_scores)

		"ERROR":
			var error_msg = data.get("message", "Unknown error")
			DebugHelper.log_error("NetworkManager: Server error - %s" % error_msg)

		_:
			DebugHelper.log_debug("NetworkManager: Unknown message type: %s" % msg_type)

# ============================================
# Lobby Management
# ============================================

func create_lobby() -> void:
	if state != ConnectionState.CONNECTED:
		connect_to_relay()
		await SignalBus.network_connected

	send_message({
		"type": "CREATE_LOBBY",
		"name": player_name
	})

func join_lobby(code: String) -> void:
	if state != ConnectionState.CONNECTED:
		connect_to_relay()
		await SignalBus.network_connected

	send_message({
		"type": "JOIN_LOBBY",
		"code": code.to_upper(),
		"name": player_name
	})

func leave_lobby() -> void:
	send_message({"type": "LEAVE_LOBBY"})
	lobby_code = ""
	players.clear()
	state = ConnectionState.CONNECTED

func set_ready(ready: bool) -> void:
	send_message({
		"type": "SET_READY",
		"ready": ready
	})

func start_game() -> void:
	if not is_host:
		return

	send_message({"type": "START_GAME"})

# ============================================
# In-Game Communication
# ============================================

func send_score_update(score: int) -> void:
	send_message({
		"type": "SCORE_UPDATE",
		"score": score
	})

func send_word_completed(word: String) -> void:
	send_message({
		"type": "WORD_COMPLETED",
		"word": word
	})

func send_game_over(won: bool, final_score: int) -> void:
	send_message({
		"type": "GAME_OVER",
		"won": won,
		"score": final_score
	})

# ============================================
# Utility
# ============================================

func set_player_name(name: String) -> void:
	player_name = name

func is_network_connected() -> bool:
	return state != ConnectionState.DISCONNECTED and state != ConnectionState.CONNECTING

func is_in_lobby() -> bool:
	return state == ConnectionState.IN_LOBBY

func is_in_game() -> bool:
	return state == ConnectionState.IN_GAME

func get_player_count() -> int:
	return players.size() + 1  # +1 for self
